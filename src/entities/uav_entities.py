import numpy as np
import math
from collections import namedtuple

from src.utilities import config, utilities


class SimulatedEntity:
    """ A simulated entity keeps track of the simulation object, where you can access all the parameters
    of the simulation. No class of this type is directly instantiable.
    """

    def __init__(self, simulator):
        self.simulator = simulator


# ------------------ Entities ----------------------
class Entity(SimulatedEntity):
    """ An entity in the environment, e.g. Drone, Event, Packet. It extends SimulatedEntity. """

    def __init__(self, identifier: int, coords: tuple, simulator):
        super().__init__(simulator)
        self.identifier = identifier  # the id of the entity
        self.coords = coords  # the coordinates of the entity on the map

    def __eq__(self, other):
        """ Entity objects are identified by their id. """
        if not isinstance(other, Entity):
            return False
        else:
            return other.identifier == self.identifier

    def __hash__(self):
        return hash((self.identifier, self.coords))


# ------------------ Event -----------------------
# Created in feel_event, not a big deal
class Event(Entity):
    """ An event is any kind of event that the drone detects on the aoi. It is an Entity. """

    def __init__(self, coords: tuple, current_time: int, simulator, deadline=None):
        super().__init__(id(self), coords, simulator)
        self.current_time = current_time

        # One can specify the deadline or just consider as deadline now + EVENTS_DURATION
        # The deadline of an event represents the estimate of the drone that the event will be no more
        # interesting to monitor.
        self.deadline = current_time + self.simulator.event_duration if deadline is None else deadline

        # add metrics: all the events generated during the simulation
        # GENERATED_EVENTS
        if not coords == (-1, -1) and not current_time == -1:
            self.simulator.metrics.events.add(self)

    def to_json(self):
        """ return the json repr of the obj """
        return {"coord": self.coords,
                "i_gen": self.current_time,
                "i_dead": self.deadline,
                "id": self.identifier
                }

    def is_expired(self, cur_step):
        """ return true if the deadline expired """
        return cur_step > self.deadline

    def as_packet(self, time_step_creation, drone):
        """ build a packet out of the event, by default the packet has deadline set to that of the event
            so the packet dies at the same time of the event, then add the input drone as first hop
        """
        # Notice: called only when a packet is created

        pck = DataPacket(time_step_creation, self.simulator, event_ref=self)
        # if config.DEBUG_PRINT_PACKETS: print("data", pck, pck.src_drone, pck.dst_drone, self.current_time)
        pck.add_hop(drone)
        return pck

    def __repr__(self):
        return "Ev id:" + str(self.identifier) + " c:" + str(self.coords)


# ------------------ Packet ----------------------
class Packet(Entity):
    """ A packet is an object created out of an event monitored on the aoi. """

    def __init__(self, time_step_creation, simulator, event_ref: Event = None):
        """ the event associated to the packet, time step in which the packet was created
         as for now, every packet is an event. """

        event_ref_crafted = event_ref if event_ref is not None else Event((-1, -1), -1,
                                                                          simulator)  # default event if packet is not associated to the event

        # id(self) is the id of this instance (unique for every new created packet),
        # the coordinates are those of the event
        super().__init__(id(self), event_ref_crafted.coords, simulator)

        self.time_step_creation = time_step_creation
        self.event_ref = event_ref_crafted
        self.__TTL = -1  # TTL is the number of hops that the packet crossed
        self.__max_TTL = self.simulator.packets_max_ttl
        self.number_retransmission_attempt = 0

        # self.hops = set()  # All the drones that have received/transmitted the packets
        self.last_2_hops = []
        # add metrics: all the packets generated by the drones, either delivered or not (union of all the buffers)
        if event_ref is not None:
            self.add = self.simulator.metrics.drones_packets.add(self)

        self.optional_data = None  # list
        self.time_delivery = None

        # if the packet was sent with move routing or not
        self.is_move_packet = None

    def distance_from_depot(self):
        return utilities.euclidean_distance(self.simulator.depot_coordinates, self.coords)

    def age_of_packet(self, cur_step):
        return cur_step - self.time_step_creation

    def to_json(self):
        """ return the json repr of the obj """

        return {"coord": self.coords,
                "i_gen": self.time_step_creation,
                "i_dead": self.event_ref.deadline,
                "id": self.identifier,
                "TTL": self.__TTL,
                "id_event": self.event_ref.identifier}

    def add_hop(self, drone):
        """ add a new hop in the packet """

        if len(self.last_2_hops) == 2:
            self.last_2_hops = self.last_2_hops[1:]  # keep just the last two HOPS
        self.last_2_hops.append(drone)

        # self.hops.add(drone.identifier)
        self.increase_TTL_hops()

    def increase_TTL_hops(self):
        self.__TTL += 1

    def increase_transmission_attempt(self):
        self.number_retransmission_attempt += 1

    def is_expired(self, cur_step):
        """ a packet expires if the deadline of the event expires, or the maximum TTL is reached """
        return cur_step > self.event_ref.deadline  # or self.__TTL > self.__max_TTL  # TODO: questionable

    def __repr__(self):
        packet_type = str(self.__class__).split(".")[-1].split("'")[0]
        return packet_type + "id:" + str(self.identifier) + " event id: " + str(
            self.event_ref.identifier) + " c:" + str(self.coords)

    def append_optional_data(self, data):
        """ append optional data in the hello emssage to share with neigh drones somethings """
        self.optional_data = data


class DataPacket(Packet):
    """ Basically a Packet"""

    def __init__(self, time_step_creation, simulator, event_ref: Event = None):
        super().__init__(time_step_creation, simulator, event_ref)


class ACKPacket(Packet):
    def __init__(self, src_drone, dst_drone, simulator, acked_packet, time_step_creation=None):
        super().__init__(time_step_creation, simulator, None)
        self.acked_packet = acked_packet  # packet that the drone who creates it wants to ACK

        # source and destination of a packet
        self.src_drone = src_drone
        self.dst_drone = dst_drone


class HelloPacket(Packet):
    """ The hello message is responsible to give info about neighborhood """

    def __init__(self, src_drone, time_step_creation, simulator, cur_pos, speed, next_target):
        super().__init__(time_step_creation, simulator, None)
        self.cur_pos = cur_pos
        self.speed = speed
        self.next_target = next_target
        self.src_drone = src_drone


class HearthBeat(Packet):
    """ An HearthBeat message is responsible to continue the tree or to broke it """

    def __init__(self, src, time_step_creation, simulator, optional_command):
        """

        :param src: who send to me the packet
        :param time_step_creation: the time of creation of this packet
        :param simulator: the simulator istance
        :param optional_command:  0 (continue the tree) --- 1 (broke the tree)  --- 2 (start send the data)
        """
        super().__init__(time_step_creation, simulator, None)
        self.src = src
        self.time_step_creation = time_step_creation
        self.simulator = simulator
        self.optional_command = optional_command


class ParentPacket(Packet):
    """Un ParentPacket message viene utilizzato per verificare se c'Ã¨ un ciclo o meno"""

    def __init__(self, src, time_step_creation, simulator, optional_command):
        super().__init__(self, time_step_creation, simulator, None)
        self.src = src
        self.time_step_creation = time_step_creation
        self.simulator = simulator


# ------------------ Depot ----------------------
class Depot(Entity):
    """ The depot is an Entity. """

    def __init__(self, coords, communication_range, simulator):

        super().__init__(id(self), coords, simulator)
        self.communication_range = communication_range

        self.__buffer = list()  # also with duplicated packets

    def all_packets(self):
        return self.__buffer

    def transfer_notified_packets(self, drone, cur_step):
        """ function called when a drone wants to offload packets to the depot """

        packets_to_offload = drone.all_packets()
        self.__buffer += packets_to_offload

        for pck in packets_to_offload:
            # add metrics: all the packets notified to the depot
            self.simulator.metrics.drones_packets_to_depot.add((pck, cur_step))
            self.simulator.metrics.drones_packets_to_depot_list.append((pck, cur_step))
            pck.time_delivery = cur_step

    def send_hearth_beat(self, cur_step):
        """ this method is responsable to send hearth beat to the drones
            The hearth beat is used to check connectivity with the depot
         """
        if cur_step % config.HELLO_DELAY == 0:
            all_drones = self.simulator.drones
            closest_drones = [drone for drone in all_drones
                              if utilities.euclidean_distance(self.coords, drone.coords)
                              < min(self.communication_range, drone.communication_range)]

            opt_command = 0

            hearth_packet = HearthBeat(self, cur_step, self.simulator, opt_command)
            for drone in closest_drones:
                self.simulator.network_dispatcher.send_packet_to_medium(hearth_packet, self, drone,
                                                                        cur_step)


# ------------------ Drone ----------------------
class Drone(Entity):

    def __init__(self, identifier: int, path: list, depot: Depot, simulator):

        super().__init__(identifier, path[0], simulator)

        # new fields
        # self.distance_between_drones = self.simulator.drone_com_range - 1
        # self.count_into_pathParent = 100
        self.count = 0
        self.type_drone = "SVF"
        self.parentPath = None
        self.check_cycle = False
        self.timer = 1000
        self.all_connected = False
        self.flag_all_connected = True
        self.flag_move = False
        self.flag_goes_out_network = False
        self.history_coords = []
        ###
        self.depot = depot
        self.path = path
        self.speed = self.simulator.drone_speed
        self.sensing_range = self.simulator.drone_sen_range
        self.communication_range = self.simulator.drone_com_range
        self.buffer_max_size = self.simulator.drone_max_buffer_size
        self.residual_energy = self.simulator.drone_max_energy
        self.come_back_to_mission = False  # if i'm coming back to my applicative mission
        self.last_move_routing = False  # if in the last step i was moving to depot
        self.stop = False

        # dynamic parameters
        self.tightest_event_deadline = None  # used later to check if there is an event that is about to expire
        self.current_waypoint = 0

        self.__buffer = []  # contains the packets

        self.distance_from_depot = 0
        self.move_routing = False  # if true, it moves to the depot
        # setup drone routing algorithm
        self.routing_algorithm = self.simulator.routing_algorithm.value(self, self.simulator)

        # drone state simulator

        # last mission coord to restore the mission after movement
        self.last_mission_coords = None

    def update_packets(self, cur_step):
        """ removes the expired packets from the buffer
        """
        to_remove_packets = 0
        tmp_buffer = []
        self.tightest_event_deadline = np.nan

        for pck in self.__buffer:
            if not pck.is_expired(cur_step):
                tmp_buffer.append(pck)  # append again only if it is not expired
                self.tightest_event_deadline = np.nanmin([self.tightest_event_deadline, pck.event_ref.deadline])
            else:
                to_remove_packets += 1
        self.__buffer = tmp_buffer

        # TODO(da sistemare): da problemi e i droni non si muovono verso il depot
        if self.buffer_length() == 0:
            self.move_routing = False

    def packet_is_expiring(self, cur_step):
        """ return true if exist a packet that is expiring and must be returned to the depot as soon as possible
            -> start to move manually to the depot.

            This method is optional, there is flag src.utilities.config.ROUTING_IF_EXPIRING
        """
        time_to_depot = self.distance_from_depot / self.speed
        event_time_to_dead = (self.tightest_event_deadline - cur_step) * self.simulator.time_step_duration
        return event_time_to_dead - 5 < time_to_depot <= event_time_to_dead  # 5 seconds of tolerance

    def next_move_to_mission_point(self):
        """ get the next future position of the drones, according the mission """
        current_waypoint = self.current_waypoint
        if current_waypoint >= len(self.path) - 1:
            current_waypoint = -1

        p0 = self.coords
        p1 = self.path[current_waypoint + 1]
        all_distance = utilities.euclidean_distance(p0, p1)
        distance = self.simulator.time_step_duration * self.speed
        if all_distance == 0 or distance == 0:
            return self.path[current_waypoint]

        t = distance / all_distance
        if t >= 1:
            return self.path[current_waypoint]
        elif t <= 0:
            print("Error move drone, ratio < 0")
            exit(1)
        else:
            return (((1 - t) * p0[0] + t * p1[0]), ((1 - t) * p0[1] + t * p1[1]))

    def feel_event(self, cur_step):
        """ feel a new event, and adds the packet relative to it, in its buffer.
            if the drones is doing movement the packet is not added in the buffer
         """
        ev = Event(self.coords, cur_step, self.simulator)  # the event
        pk = ev.as_packet(cur_step, self)  # the packet of the event
        if not self.move_routing and not self.come_back_to_mission:
            self.__buffer.append(pk)
        else:  # store the events that are missing due to movement routing
            self.simulator.metrics.events_not_listened.add(ev)

    def accept_packets(self, packets):
        """ Self drone adds packets of another drone, when it feels it passing by. """

        for packet in packets:
            # add if not notified yet, else don't, proprietary drone will delete all packets, but it is ok
            # because they have already been notified by someone already

            if not self.is_known_packet(packet):
                self.__buffer.append(packet)

    def routing(self, drones, depot, cur_step):
        """ do the routing """
        self.distance_from_depot = utilities.euclidean_distance(self.depot.coords, self.coords)
        self.routing_algorithm.routing(depot, drones, cur_step)

    # def move_CPVF(self,parentDrone):
    #     if math.ceil(utilities.euclidean_distance(self.coords, parentDrone.coords)) < self.communication_range:
    #         print("Rimaniamo dentro il raggio del parent drone")
    #         if (math.ceil(utilities.euclidean_distance(self.coords, parentDrone.coords))) == self.communication_range:
    #             self.stop = True
    #             return
    #     self.stop = False

    def update_time_to_create_networks_of_drones(self, cur_step):
        """Se tutti i droni sono connessi aggiorna la metrica del tempo"""
        drones = self.simulator.drones
        # se non abbiamo ancora la rete con tutti i droni connessi al depot allora incrementiamo il tempo.
        if (self.all_connected == True and self.flag_all_connected == True):
            self.simulator.metrics.time_to_create_network_of_drones = cur_step
            for drone in drones:
                drone.flag_all_connected = False

        # #switch in questa versione per vedere solo il current step
        # self.simulator.metrics.time_to_create_network_of_drones = cur_step

    def lazy_movement(self, time):
        """Qui vengono rallentati i movimenti del drone e abbiamo vari casi:
       1. Il nostro drone ha trovato il suo path parent e controlla chi Ã¨ piÃ¹ vicino al depot, se il nostro drone Ã¨ piÃ¹ vicino al depot, si sgancia
          dal parent e continua muoversi liberamente.
       2. Se il nostro drone ha trovato il path parent che Ã¨ piÃ¹ lontano dal depot e si trova al confine del "communication_range",
          allora si ferma.
       3. Se il nostro drone ha trovato il path parent, che Ã¨ piÃ¹ lontano dal depot, ma non si trova al confine del "communication_range" allora
          continuerÃ  a muoversi, fino a che non raggiungerÃ  il confine del parent corrente """
        if self.type_drone == "CPVF":
            # drones = self.simulator.drones
            if (self.parentPath != None):
                myDrone_distance_depot = utilities.euclidean_distance(self.coords, self.simulator.depot_coordinates)
                parentDrone_distance_depot = utilities.euclidean_distance(self.parentPath.coords,
                                                                          self.simulator.depot_coordinates)
                # print("Dist del mio drone dal depot", myDrone_distance_depot)
                # print("Dist del parentDrone dal depot", parentDrone_distance_depot)
                # print("Mio Drone:", str(self.identifier), "Drone parent", str(self.parentPath.identifier))
                if (myDrone_distance_depot < parentDrone_distance_depot):
                    # if (self.identifier == 9):
                    #     print("uno")
                    self.parentPath = None
                    self.stop = False
                    self.timer = 1000
                    # self.last_mission_coords = self.coords
                elif (self.routing_algorithm.is_connected) == False:
                    # if (self.identifier == 9):
                    #     print("due")
                    # self.parentPath = None
                    # self.stop = False
                    # self.timer = 1000
                    # self.last_mission_coords = self.coords
                    if self.last_mission_coords != self.coords:
                        self.last_mission_coords = self.coords
                    else:
                        for i in range(len(self.path)):
                            if self.path[i] != self.coords:
                                self.last_mission_coords = self.path[i]
                                break
                    # controlliamo che la coordinata non Ã¨ all'interno dello stesso parent!
                    if utilities.euclidean_distance(self.last_mission_coords,
                                                    self.parentPath.coords) < self.communication_range:
                        for i in range(len(self.path)):
                            self.last_mission_coords = self.path[i]
                            if utilities.euclidean_distance(self.last_mission_coords,
                                                            self.parentPath.coords) < self.communication_range:
                                continue
                            else:
                                break

                    # print("SIAMO NOI DRONE", self.identifier, self.routing_algorithm.is_connected,
                    #       self.parentPath.identifier, self.stop)
                    self.parentPath = None
                    self.stop = False
                    self.timer = 1000
                    self.flag_move = True

                    # in direzione del depot tutti droni.
                elif self.parentPath.identifier == self.depot.identifier:
                    # if (self.identifier == 9):
                    #     print("tre")
                        #print(utilities.euclidean_distance(self.coords,self.depot.coords))
                    # print("CIAONE")
                    # drones = self.simulator.drones
                    if (math.ceil(
                            utilities.euclidean_distance(self.coords, self.depot.coords)) == self.communication_range) or\
                        (math.ceil(
                            utilities.euclidean_distance(self.coords, self.depot.coords)) == self.communication_range-1) or \
                        (math.ceil(
                                utilities.euclidean_distance(self.coords,
                                                             self.depot.coords)) == self.communication_range - 2) or \
                        (math.ceil(
                                utilities.euclidean_distance(self.coords,
                                                             self.depot.coords)) == self.communication_range - 3) or \
                        (math.ceil(
                                utilities.euclidean_distance(self.coords,
                                                             self.depot.coords)) == self.communication_range - 4) or \
                        (math.ceil(
                                utilities.euclidean_distance(self.coords,
                                                             self.depot.coords)) == self.communication_range - 5):
                        # if (self.identifier == 23):
                        #     print("BLOCCATO")
                        self.stop = True
                        # self.flag_move = True
                    # self.move_routing = False

                    # self.coords = self.last_mission_coords

                elif self.parentPath.identifier != self.depot.identifier and self.routing_algorithm.is_connected and self.parentPath.stop and \
                        (math.ceil(utilities.euclidean_distance(self.coords,
                                                               self.parentPath.coords)) == self.communication_range or \
                        math.ceil(utilities.euclidean_distance(self.coords,
                                                               self.parentPath.coords)) == self.communication_range - 1 or \
                        math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.parentPath.coords)) == self.communication_range - 2 or \
                        math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.parentPath.coords)) == self.communication_range - 3 or \
                        math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.parentPath.coords)) == self.communication_range - 4 or \
                        math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.parentPath.coords)) == self.communication_range - 5):
                    # if (self.identifier == 9):
                    #     print("quattro")
                    #     math.ceil(utilities.euclidean_distance(self.coords, self.parentPath.coords)) in range(
                    # self.communication_range - 15, self.communication_range + 1):
                    #:

                    # print("Confine, blocca")

                    self.stop = True
                elif self.routing_algorithm.is_connected and \
                        (utilities.euclidean_distance(self.coords,
                                                               self.parentPath.coords)) < self.communication_range-5:
                    # if (self.identifier == 9):
                    #     print("cinque")
                    # math.ceil(utilities.euclidean_distance(self.coords, self.parentPath.coords)) < (self.communication_range - 15):

                    # print("Parentpath:", self.parentPath.identifier, "Depot:", self.depot.identifier)
                    if utilities.euclidean_distance(self.last_mission_coords,
                                                    self.parentPath.coords) < self.communication_range:
                        for i in range(len(self.path)):
                            if utilities.euclidean_distance(self.path[i],
                                                            self.parentPath.coords) < self.communication_range:
                                continue
                            else:
                                self.last_mission_coords = self.path[i]

                    # print("Siamo dentro il parent")
                    self.stop = False
                    self.come_back_to_mission = True


        elif self.type_drone == "SVF":
            if (self.parentPath != None):
                myDrone_distance_depot = utilities.euclidean_distance(self.coords, self.simulator.depot_coordinates)
                parentDrone_distance_depot = utilities.euclidean_distance(self.parentPath.coords,
                                                                          self.simulator.depot_coordinates)
                #se la lunghezza dell'history delle cordinate Ã¨ uguale a quella del path azzeriamo l'history
                if len(self.history_coords) == len(self.path):
                    self.history_coords = []
                #prendiamo i droni
                drones = self.simulator.drones
                # se il nostro drone Ã¨ piÃ¹ vicino del parent al depot, non si aggancia al parent e continua a muoversi.
                if (myDrone_distance_depot < parentDrone_distance_depot)  and self.parentPath.identifier != self.depot.identifier and \
                        self.parentPath.stop and self.flag_goes_out_network != True:
                    if (self.identifier == 7):
                        print("uno")
                    self.parentPath = None
                    self.stop = False
                    self.timer = 1000
                    # self.flag_goes_out_network = True #ho messo adesso
                    # return
                    # TODO provare ad aggiungere che va verso il depot.
                # se il nostro drone si trova senza parent path, allora selezioniamo una coordinata libera dove mandare il
                # drone. Per libera si intende che non Ã¨ all'interno di nessun communication_range di alcun drone.
                # Inoltre andiamo a prendere una destinazione che non abbiamo giÃ  visitato.
                #In questo modo il drone si muoverÃ  verso un punto, in cui non ci sono altri droni, ma nel suo cammino,
                #potrebbe incontrare altri droni e quindi trovare il suo parent.
                # E' una sorta di reset per far ricominciare un po' da capo il drone che ha appena
                # perso il suo potenziale parent.

                if(self.parentPath == None):
                    if(self.identifier == 7):
                        print("NONE")

                    #self.flag_goes_out_network = True
                    for i in range(len(self.path)):
                        right_distance = True
                        self.last_mission_coords = self.path[i]
                        # if (self.identifier == 7):
                        #     print(self.last_mission_coords)
                        #     print(self.history_coords)
                        if self.last_mission_coords in self.history_coords:
                            continue
                        else:
                            self.history_coords.append(self.last_mission_coords)
                        for drone in drones:
                                if drone.identifier != self.identifier and drone.stop and  \
                                        (utilities.euclidean_distance(self.last_mission_coords,
                                                                      drone.coords) < self.communication_range):
                                    # if self.last_mission_coords not in self.history_coords:
                                    #     self.history_coords.append(self.last_mission_coords)

                                    right_distance = False
                                    break
                        if right_distance == True:
                            return
                # ToDo da sistemare questo commento.

               # il nostro drone ha il parent, non Ã¨ connesso, il suo parent non Ã¨ il depot, il parent Ã¨ fermo (quindi
               # si Ã¨ agganciato alla rete e si Ã¨ espanso posizionandosi al confine del suo parent e il nostro drone
               # non ha il flag per andare all'esterno della rete attivato. Mettiamo come last_coords quella del parent
               # e attiviamo il flag per andare all'esterno della rete, in questa maniera il nostro drone si avvicinerÃ 
               # al confine e qualora dovesse uscire all'esterno avrÃ  come riferimento la coordinata del parent per
               # tornare al suo interno.
                if (self.parentPath != None) and (self.routing_algorithm.is_connected) == False and \
                        self.parentPath.identifier != self.simulator.depot.identifier and \
                        self.parentPath.stop and self.flag_goes_out_network != True:
                    if (self.identifier == 7):
                        print("due")
                    # self.flag_goes_out_network = False #prima era false

                    self.last_mission_coords = self.parentPath.coords
                    if self.last_mission_coords not in self.history_coords:
                        self.history_coords.append(self.last_mission_coords)  # nuova parte
                    self.flag_goes_out_network = True

                    # # for i in range(len(self.path)):
                    # #     if self.last_mission_coords == self.coords:
                    # #         if self.path[i] != self.coords:
                    # #             self.last_mission_coords = self.path[i]
                    # #         else:
                    # #             break
                    # right_distance = True
                    # for drone in drones:
                    #     if self.identifier != drone.identifier and drone.stop and\
                    #         utilities.euclidean_distance(self.last_mission_coords,
                    #                                      drone.coords) < self.communication_range:
                    #
                    #         right_distance = False
                    #         break
                    # if right_distance:
                    #     if (self.identifier == 5):
                    #        print("ECCO")
                    #     self.flag_goes_out_network = True
                    #     #return
                    #
                    # # elif self.last_mission_coords != self.coords:
                    # #      self.last_mission_coords = self.coords
                    #      #self.flag_goes_out_network = True #nuovo
                    # else:
                    #     for i in range(len(self.path)):
                    #         if self.path[i] != self.coords:
                    #             self.last_mission_coords = self.path[i]
                    #             break
                    # controlliamo che la coordinata non Ã¨ all'interno dello stesso parent!
                    # if utilities.euclidean_distance(self.last_mission_coords,
                    #                                 self.parentPath.coords) < self.communication_range:
                    #     for i in range(len(self.path)):
                    #         self.last_mission_coords = self.path[i]
                    #         if utilities.euclidean_distance(self.last_mission_coords,
                    #                                         self.parentPath.coords) < self.communication_range:
                    #             continue
                    #         else:
                    #             break


                # se il nostro drone ha il parent, ma non Ã¨ connesso, il suo parent non Ã¨ il depot, il suo parent non Ã¨
                # fermo e il flag per uscire dalla rete Ã¨ disattivato allora assegniamo una coordinata, in cui il nostro
                # drone dovrÃ  andare, che non sia all'interno dello stesso parent. Qui il parent path viene di nuovo
                # perso, perchÃ© il path parent non Ã¨ ancora fermo e agganciato alla rete, in aggiunta il flag per non
                # andare verso il depot viene attivato, questo perchÃ© quando si trova il parent, di solito
                # si va in una direzione che Ã¨ verso il depot.
                if (self.parentPath != None) and (self.routing_algorithm.is_connected) == False and \
                        self.parentPath.identifier != self.depot.identifier and self.parentPath.stop == False and \
                        self.flag_goes_out_network != True:
                    if (self.identifier == 7):
                        print("tre")
                    self.flag_goes_out_network = False
                    # if self.last_mission_coords != self.coords:
                    #     self.last_mission_coords = self.coords
                    #     if self.last_mission_coords not in self.history_coords:
                    #         self.history_coords.append(self.last_mission_coords)  # nuova parte
                    # else:
                    #     for i in range(len(self.path)):
                    #         if self.path[i] != self.coords:
                    #             self.last_mission_coords = self.path[i]
                    #             if self.last_mission_coords not in self.history_coords:
                    #                 self.history_coords.append(self.last_mission_coords)    # nuova parte
                    #             break
                    # controlliamo che la coordinata non Ã¨ all'interno dello stesso parent!
                    if utilities.euclidean_distance(self.last_mission_coords,
                                                    self.parentPath.coords) < self.communication_range:
                        for i in range(len(self.path)):
                            self.last_mission_coords = self.path[i]
                            if utilities.euclidean_distance(self.last_mission_coords,
                                                            self.parentPath.coords) < self.communication_range:
                                continue
                            else:
                                break

                    # print("SIAMO NOI DRONE", self.identifier, self.routing_algorithm.is_connected,self.parentPath.identifier, self.stop)
                    self.parentPath = None
                    self.stop = False
                    self.timer = 1000
                    self.flag_move = True
                    # return

                    # se il nostro drone ha come path parent il depot possiamo agganciarci ad esso se la distanza Ã¨ >
                    # del communication range con tutti gli altri droni. Altrimenti viene selezionata un'altra coordinata
                    # che sia esterna al depot. Inoltre perdiamo il parent. Possiamo dire che in alcuni casi il drone
                    # puÃ² bloccarsi nel entrare e uscire dal raggio di comunicazione del depot, in continuazione,
                    # quindi Ã¨ stato pensato che se dopo tot tentativi il drone si trova ancora bloccato nell'entrare
                    # uscire dal depot non trovando il giusto spazio per posizionarsi (droni troppo vicini a lui non lo
                    # permettono) allora attiviamo il flag per farlo andare verso l'esterno della rete e quindi lontano
                    # dal depot.
                if (self.parentPath != None) and self.parentPath.identifier == self.depot.identifier and \
                        (math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.depot.coords)) == self.communication_range or\
                         math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.depot.coords)) == self.communication_range - 1 or\
                         math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.depot.coords)) == self.communication_range - 2 )  :
                    # print("CIAONE DEPOT")
                    if (self.identifier == 7):
                        print("quattro")
                    drones = self.simulator.drones
                    right_distance = True

                    # print("Distanza communication:", self.distance_between_drones)
                    for drone in drones:
                        # print("(IN DEPOT Fuori dall'if) Drone:", self.identifier, "Distance da drone:",
                        #       drone.identifier, "Ã¨", utilities.euclidean_distance(self.coords, drone.coords))
                        if drone.identifier != self.identifier and drone.stop and \
                                (utilities.euclidean_distance(self.coords,
                                                              drone.coords) < self.communication_range - 1):
                            # print("(IN DEPOT) Drone:", self.identifier, "Distance da drone:",
                            #       drone.identifier, "Ã¨", utilities.euclidean_distance(self.coords, drone.coords))
                            right_distance = False
                            self.stop = False
                            break

                    if right_distance and (self.coords != self.depot.coords):
                        print(self.identifier,"fermo al depot")
                        self.stop = True
                        return
                    else:
                        if (self.identifier == 7):
                            print("BLOCCATO")


                        # self.parentPath = None #aggiunto adesso
                        # print(self.parentPath.identifier)
                        if (utilities.euclidean_distance(self.coords,
                                                         self.depot.coords) < self.communication_range):
                            # print("qui")
                            for i in range(len(self.path)):
                                # da togliere dopo
                                # if self.identifier == 13:
                                #     print(self.history_coords)
                                #     print(self.path[i])
                                #####

                                if self.path[i] in self.history_coords:
                                    continue
                                else:
                                    self.last_mission_coords = self.path[i]
                                    self.history_coords.append(self.last_mission_coords)

                                if (utilities.euclidean_distance(self.last_mission_coords,
                                                                self.depot.coords) < self.communication_range):

                                    # if self.identifier == 13:
                                    #
                                    #     print("BLOCCATO ECCOCI")
                                    continue

                                else:
                                    print(self.last_mission_coords)
                                    break# nuova parte
                        if self.identifier == 7:
                            print("BLOCCATO ECCOCI2")
                        self.parentPath = None
                        # if self.flag_goes_out_network == False:
                        #     if self.identifier == 5:
                        #         print("IF")

                        if self.count > 10:
                            self.flag_goes_out_network = True
                        else:
                            self.count += 1
                        # else:
                        #     if self.identifier == 5:
                        #         print("ELSE")
                        #     self.flag_goes_out_network = False
                        #self.move = False
                        #self.flag_goes_out_network = True   #in prova con tutto!
                        return
                        # self.flag_move = True
                    # return
                # self.come_back_to_mission = True

                # se il nostro drone ha trovato un path parent che Ã¨ diverso dal depot, questo path parent Ã¨ fermo e il
                # nostro drone si trova al confine, allora si aggancerÃ (fermandosi) ad esso solo se si troverÃ  al confine
                # e lontano abbastanza da tutti gli altri droni (circa il communication range). Altrimenti si muoverÃ 
                # verso l'esterno della rete.
                if (self.parentPath != None) and self.parentPath.identifier != self.depot.identifier and \
                        self.parentPath.stop and \
                        (math.ceil(utilities.euclidean_distance(self.coords,
                                                               self.parentPath.coords)) == self.communication_range or\
                         math.ceil(utilities.euclidean_distance(self.coords,
                                                               self.parentPath.coords)) == self.communication_range -1 or \
                         math.ceil(utilities.euclidean_distance(self.coords,
                                                                self.parentPath.coords)) == self.communication_range - 2) :
                    if (self.identifier == 7):
                        print("cinque")
                    right_distance = True
                    # print("Nome drone:", self.identifier, "Distanza:",
                    #       utilities.euclidean_distance(self.coords, self.parentPath.coords), "dal drone parent:",
                    #       self.parentPath.identifier)
                    for drone in drones:
                        if self.identifier != drone.identifier and drone.stop and self.parentPath.identifier != drone.identifier and\
                                (utilities.euclidean_distance(self.coords,
                                                              drone.coords) < self.communication_range - 6):
                            if self.identifier == 7:
                                print("ERRORE")
                            right_distance = False
                            break

                    if right_distance == True and utilities.euclidean_distance(self.coords,
                                                                               self.depot.coords) >= self.communication_range:

                        # if self.identifier == 7:
                        print(self.identifier,"FERMO")
                        self.stop = True
                        return
                    else:
                        self.flag_goes_out_network = True


                # se il nostro drone ha il parent che Ã¨ diverso dal depot, ma il nostro drone si trova all'interno del
                # depot, allora dobbiamo selezionare una prossima destinazione che Ã¨ all'esterno del depot e che non Ã¨
                # stata presa in considerazione in precedenza. Anche in questo caso, possiamo dire che in alcuni casi il
                # drone puÃ² bloccarsi nel entrare e uscire dal raggio di comunicazione del depot, in continuazione,
                # quindi Ã¨ stato pensato che se dopo tot tentativi il drone si trova ancora bloccato
                # nell'entrare e uscire dal depot, allora il nostro drone viene forzato ad andare  verso l'esterno
                # della rete connessa.
                if (self.parentPath != None) and self.parentPath.identifier != self.depot.identifier and (
                        (utilities.euclidean_distance(self.coords,
                                                               self.depot.coords)) < self.communication_range):
                    if self.identifier == 7:
                        print("NEW")
                    #     print(self.parentPath.identifier)
                    # self.last_mission_coords = self.parentPath.coords
                    for i in range(len(self.path)):
                        self.last_mission_coords = self.path[i]
                        if (utilities.euclidean_distance(self.last_mission_coords,
                                                                  self.depot.coords)) < self.communication_range:

                            if self.path[i] == self.coords:
                                continue
                            if self.path[i] in self.history_coords:
                                continue
                            else:
                                self.last_mission_coords = self.path[i]
                                self.history_coords.append(self.last_mission_coords)

                        else:

                            break
                    # if(self.identifier == 1):
                    #     print(self.parentPath.identifier)
                    #     print(utilities.euclidean_distance(self.coords,self.parentPath.coords))
                    #     print(utilities.euclidean_distance(self.last_mission_coords, self.parentPath.coords))

                    # if self.flag_goes_out_network != True:
                    if self.identifier == 7:
                        print(self.count)

                    # if self.count < 50:
                    #     self.count += 1
                    if self.count > 10:
                        self.flag_goes_out_network = True
                    else:
                        self.count += 1

                #da testare se puÃ² andare.
                    # else:
                    #    self.flag_goes_out_network = False
                    # return
                # se il nostro path parent Ã¨ diverso dal depot ma siamo all'interno del parent e siamo all'esterno del
                # depot e il nostro flag per uscire dalla rete Ã¨ attivo, allora dobbiamo cercare di arrivare al confine
                # del parent, ma se il nostro parent si trova all'interno della rete, allora il nostro drone dovrÃ 
                # andare al di fuori della rete. Viene selezionata una coordinata che deve essere esterna a tutti i droni
                # fermi.
                if (self.parentPath != None) and \
                        self.parentPath.identifier != self.depot.identifier \
                        and self.parentPath.stop and (utilities.euclidean_distance(self.coords,self.depot.coords) > self.communication_range) and\
                        (utilities.euclidean_distance(self.coords, self.parentPath.coords) <
                        self.communication_range - 5) and self.flag_goes_out_network != False:

                    if (self.identifier == 7):
                        print("sei", self.parentPath.identifier)
                    # la coordinata deve essere al di fuori di tutti i droni.
                    right_distance = True
                    for drone in drones:
                        # if(self.identifier == 9):
                        #     print("DIECI","coordinata drone:",self.coords,"direzione drone",self.last_mission_coords,"drone comparato", drone.identifier, "sua coordinata", drone.coords)
                        if drone.identifier != self.identifier and drone.stop and \
                                (utilities.euclidean_distance(self.last_mission_coords,
                                                              drone.coords) < self.communication_range):
                            if(self.identifier == 7):
                                print("siamo qui")
                            # if (self.identifier == 10):
                            #     print("dieci")
                            # if self.identifier == 20:
                            #       print("sei ERROR", self.last_mission_coords, drone.coords)
                            right_distance = False
                            break

                    if right_distance == False:
                        # viene assegnata una coordinata nuova...

                        for i in range(len(self.path)):
                            right_distance = True
                            # if self.identifier == 4:
                            #     print(self.path[i])

                            if self.path[i] in self.history_coords:
                                # print(self.identifier,self.last_mission_coords)
                                # print(self.history_coords)
                                # if self.identifier == 4:
                                #     print("BOHHHH")
                                # if self.identifier == 12:
                                #     print(i)

                                if i == len(self.path)-1:    ###NEW PICCOLA MODIFICA
                                    if self.identifier == 7:
                                        print(len(self.path)-1, i)
                                    self.history_coords = []
                                    break
                                continue
                            else:
                                if self.identifier == 7:
                                    print("BINGO")
                                self.last_mission_coords = self.path[i]
                                self.history_coords.append(self.path[i])

                            for drone in drones:
                                # questa coordinata non si deve trovare all'interno del range di nessun drone
                                if drone.identifier != self.identifier and drone.stop and \
                                        (utilities.euclidean_distance(self.last_mission_coords,
                                                                      drone.coords) < self.communication_range):
                                    right_distance = False
                                    break

                            if right_distance == True:
                                # self.last_mission_coords = temp
                                # if( self.identifier == 20):
                                #      print("RIGHT", self.last_mission_coords)

                                self.flag_goes_out_network = True
                                break



                    else:
                        # if (self.identifier == 21):
                        #     print("Ramo else")

                        self.flag_goes_out_network = True
                        return
                    # print("Siamo dentro il parent")
                    # self.flag_all_connected = True
                    self.stop = False

                    # self.come_back_to_mission = True
                    # return

                #altrimenti se il nostro drone non Ã¨ connesso e il flag per andare all'esterno della rete Ã¨ attivo,
                # abbiamo il parent, il quale Ã¨ diverso dal depot e questo parent Ã¨ anche fermo, allora il flag per andare
                # verso l'esterno resterÃ  a True per tot tentativi e poi verrÃ  messo a False, quindi non andarÃ  piÃ¹ verso
                # l'esterno della rete.
                elif self.routing_algorithm.is_connected != True and self.flag_goes_out_network == True and \
                        self.parentPath != None and self.parentPath.identifier != self.depot.identifier and \
                        self.parentPath.stop:
                    # and \
                    # (utilities.euclidean_distance(self.last_mission_coords,
                    #                             self.parentPath.coords) < self.communication_range):
                    if (self.identifier == 7):
                        print("sette")
                    if self.count > 10:
                        self.flag_goes_out_network = False
                    else:
                        self.count += 1
                    # self.parentPath = None
                #       self.last_mission_coords = self.path[0]
                #     self.flag_goes_out_network = True
                # di default se non si verificano i casi precedenti, andiamo verso il confine della rete.
                # elif (self.parentPath != None):
                #     if (self.identifier == 9):
                #         print("sette")
                #     right_distance = True
                #     # la coordinata deve essere al di fuori di tutti i droni.
                #     for drone in drones:
                #         if utilities.euclidean_distance(self.last_mission_coords,
                #                                         drone.coords) < self.communication_range:
                #             right_distance = False
                #             break
                #
                #     if right_distance == False:
                #         # viene assegnata una coordinata nuova...
                #
                #         for i in range(len(self.path)):
                #             # self.last_mission_coords = self.path[i]
                #             right_distance = True
                #             temp = self.path[i]
                #
                #             for drone in drones:
                #                 # questa coordinata non si deve trovare all'interno del range di nessun drone
                #                 if utilities.euclidean_distance(temp,
                #                                                 drone.coords) < self.communication_range:
                #                     right_distance = False
                #                     break
                #             if right_distance == True:
                #                 # aggiungerei un flag per move(PER IL MOMENTO NO)
                #                 if (self.identifier == 9):
                #                     print("sei")
                #
                #                 self.last_mission_coords = temp
                #                 self.flag_goes_out_network = True
                #                 break
                #
                #     else:
                #         self.flag_goes_out_network = True  # appena aggiunto
                #         return
                #
                #     # last_drone = True
                #     # for drone in drones:
                #     #     if self.identifier != drone.identifier and drone.stop == False:
                #     #           last_drone = False
                #     #           break
                #     # if last_drone == True:
                #     #     self.stop = True
                #     self.flag_goes_out_network = True
                # return
                # self.come_back_to_mission = True
                # DA SEMPLICARE PARECCHIO
                # elif (self.routing_algorithm.is_connected) == True and \
                #         math.ceil(
                #             utilities.euclidean_distance(self.coords, self.parentPath.coords)) < self.communication_range:
                #     self.count_into_pathParent -= 1
                #     print("Drone",self.identifier,"Contatore nel parent:", self.count_into_pathParent)
                #     if self.count_into_pathParent > 0:
                #         print("Parentpath:", self.parentPath.identifier, "Depot:", self.depot.identifier)
                #         if utilities.euclidean_distance(self.last_mission_coords,
                #                                         self.parentPath.coords) < self.communication_range:
                #             for i in range(len(self.path)):
                #                 if utilities.euclidean_distance(self.path[i],
                #                                                 self.parentPath.coords) < self.communication_range:
                #                     continue
                #                 else:
                #                     self.last_mission_coords = self.path[i]
                #     else:
                #         right_distance = True
                #         for i in range(len(self.path)):
                #             for drone in drones:
                #                 if utilities.euclidean_distance(self.path[i],drone.coords) < self.communication_range:
                #                     right_distance = False
                #                     continue
                #                 else:
                #                     right_distance = True
                #                     self.last_mission_coords = self.path[i]
                #                     self.count_into_pathParent = 100
                #                     break
                #             if right_distance == True:
                #                 break
                #
                #
                #     print("Siamo dentro al parent")
                #     self.stop = False
                #     #self.flag_move = True
                #     #self.come_back_to_mission = True

    # funzione per controllare se tutti i droni sono connessi al depot, quindi se abbiamo creato la nostra rete di droni
    def check_all_connected(self):
        all_drones = self.simulator.drones
        connected = False
        for drone in all_drones:
            if drone.stop == True and drone.routing_algorithm.is_connected == True:
                connected = True
            else:

                # connected = False
                self.all_connected = False
                return

        if connected == True:
            self.all_connected = True

    # def move(self, time):
    #     """ Move the drone to the next point if self.move_routing is false, else it moves towards the depot.
    #
    #         time -> time_step_duration (how much time between two simulation frame)
    #     """
    #
    #
    #     # se il drone Ã¨ fermo, decrementiamo il timer e quando scade controlliamo se si Ã¨ verificato un ciclo.
    #     if self.stop != False:
    #         self.timer -= 1
    #         print("Drone", self.identifier, "Timer:", self.timer)
    #         self.check_all_connected()
    #
    #
    #         print("Abbiamo la rete di droni:", self.all_connected)
    #
    #         if(self.timer == 0):
    #             print("Timer scaduto")
    #             if (self.check_cycle == True):
    #                 print("Abbiamo un ciclo!")
    #                 self.stop = False
    #                 self.check_cycle = False
    #             self.timer = 1000
    #         return None
    #     # se il drone non Ã¨ fermo, il timer viene impostato al massimo.
    #     else:
    #         self.timer = 1000
    #
    #     if self.move_routing or self.come_back_to_mission:
    #         # metrics: number of time steps on active routing (movement) a counter that is incremented each time
    #         # drone is moving to the depot for active routing, i.e., move_routing = True
    #         # or the drone is coming back to its mission
    #         self.simulator.metrics.time_on_active_routing += 1
    #
    #
    #     if self.move_routing:
    #         if not self.last_move_routing:  # this is the first time that we are doing move-routing
    #             self.last_mission_coords = self.coords
    #
    #         self.__move_to_depot(time)
    #
    #     else:
    #         if self.last_move_routing:  # I'm coming back to the mission
    #             self.come_back_to_mission = True
    #
    #         self.__move_to_mission(time)
    #
    #         # metrics: number of time steps on mission, incremented each time drone is doing sensing mission
    #         self.simulator.metrics.time_on_mission += 1
    #
    #         # new
    #         # CHECK CON PRINT
    #         if (self.parentPath != None):
    #             print("Drone: " + str(self.identifier) + "  distanza: " + str(
    #                 utilities.euclidean_distance(self.coords, self.parentPath.coords))
    #                   + " communication range " + str(self.communication_range))
    #
    #         self.lazy_movement(time)
    #
    #
    #     # set the last move routing
    #
    #     self.last_move_routing = self.move_routing

    def calculate_area(self):
        # if self.all_connected and self.flag_all_connected:
        drones = self.simulator.drones
        Circle = namedtuple("Circle", "x y r")
        circles = []
        # print("AREA")
        # andiamo a creare la lista dei cerchi con le relative coordinate e il suo raggio.
        for drone in drones:
            rad = drone.communication_range
            circles.append(Circle(drone.coords[0], drone.coords[1],rad))

        # compute the bounding box of the circles
        x_min = min(c.x - c.r for c in circles)
        #print("x_min", x_min)
        x_max = max(c.x + c.r for c in circles)
        #print("x_max", x_max)
        y_min = min(c.y - c.r for c in circles)
        #print("y_min", y_min)
        y_max = max(c.y + c.r for c in circles)
        #print("y_max", y_max)

        # adattiamo la bounding box al nostro campo
        if x_min < 0 :
            x_min = 0
        if x_max > config.ENV_WIDTH:
            x_max = config.ENV_WIDTH
        if y_min < 0:
            y_min = 0
        if y_max > config.ENV_HEIGHT:
            y_max = config.ENV_HEIGHT

        box_side = 500

        dx = (x_max - x_min) / box_side
        dy = (y_max - y_min) / box_side

        count = 0

        for r in range(box_side):
            y = y_min + r * dy
            for c in range(box_side):
                x = x_min + c * dx
                if any((x - circle.x) ** 2 + (y - circle.y) ** 2 <= (circle.r ** 2)
                       for circle in circles):
                    count += 1

        # print("Approximated area:", count * dx * dy)
        self.simulator.metrics.area_covered_by_drones = count * dx * dy

        # se i droni coprono piÃ¹ area di quella prevista, arrontondiamo per difetto a 1.
        if (self.simulator.metrics.area_covered_by_drones / (self.simulator.env_width * self.simulator.env_height)) > 1.0:
            self.simulator.metrics.area_covered_by_drones_ratio = 1.0
        else:
            self.simulator.metrics.area_covered_by_drones_ratio = self.simulator.metrics.area_covered_by_drones / \
                                                              (self.simulator.env_width * self.simulator.env_height)

    def move(self, time):
        """ Move the drone to the next point if self.move_routing is false, else it moves towards the depot.

            time -> time_step_duration (how much time between two simulation frame)
        """
        if self.type_drone == "CPVF":
            # se il drone Ã¨ fermo, decrementiamo il timer e quando scade controlliamo se si Ã¨ verificato un ciclo.
            if self.stop != False:
                self.timer -= 1
                # print("Drone", self.identifier, "Timer:", self.timer)
                self.check_all_connected()
                # Qui viene richiamato il metodo per calcolare l'area:
                if self.all_connected and self.flag_all_connected:
                    self.calculate_area()

                # print("Abbiamo la rete di droni:", self.all_connected)

                if (self.timer == 0):
                    # print("Timer scaduto")
                    if (self.check_cycle == True):
                        # print("Abbiamo un ciclo!")
                        self.stop = False
                        self.check_cycle = False
                    self.timer = 1000
                return None
            # se il drone non Ã¨ fermo, il timer viene impostato al massimo.
            else:
                self.timer = 1000

            if self.flag_move == False:
                self.move_routing = True

            else:
                self.move_routing = False

            if self.move_routing or self.come_back_to_mission:
                # metrics: number of time steps on active routing (movement) a counter that is incremented each time
                # drone is moving to the depot for active routing, i.e., move_routing = True
                # or the drone is coming back to its mission
                self.simulator.metrics.time_on_active_routing += 1

            if self.move_routing:
                # print("In move routing Drone:", self.identifier)
                # self.coords = self.depot.coords
                if not self.last_move_routing:  # this is the first time that we are doing move-routing
                    self.last_mission_coords = self.coords

                self.__move_to_depot(time)

                if (self.parentPath != None):
                    # print("Drone: " + str(self.identifier) + "  distanza: " + str(
                    #     utilities.euclidean_distance(self.coords, self.parentPath.coords))
                    #       + " communication range " + str(self.communication_range))
                    self.lazy_movement(time)
                    self.flag_move = True
                else:
                    self.stop = False

                # self.flag_move = True
                # self.move_routing = False
            else:
                if self.last_move_routing:  # I'm coming back to the mission
                    self.come_back_to_mission = True

                self.__move_to_mission(time)

                # metrics: number of time steps on mission, incremented each time drone is doing sensing mission
                self.simulator.metrics.time_on_mission += 1

                # new
                # CHECK CON PRINT
                if (self.parentPath != None):
                    # print("Drone: " + str(self.identifier) + "  distanza: " + str(
                    #     utilities.euclidean_distance(self.coords, self.parentPath.coords))
                    #       + " communication range " + str(self.communication_range))
                    self.lazy_movement(time)
                else:
                    self.flag_move = False

            # if self.parentPath != None and (self.parentPath.identifier == self.depot.identifier):
            #     print("CIAONE")
            #     drones = self.simulator.drones
            #     self.stop = True
            #     #self.move_routing = False
            #     for drone in drones:
            #         drone.flag_move = True
            #     #self.coords = self.last_mission_coords

            # set the last move routing

            self.last_move_routing = self.move_routing
        elif self.type_drone == "SVF":
            # print("CPVF_NEW")

            if self.stop != False:
                self.timer -= 1
                # print("Drone", self.identifier, "Timer:", self.timer)
                self.check_all_connected()
                # Qui viene richiamato il metodo per calcolare l'area:
                if self.all_connected and self.flag_all_connected:
                    self.calculate_area()
                # print("Abbiamo la rete di droni:", self.all_connected)

                if (self.timer == 0):
                    # print("Timer scaduto")
                    if (self.check_cycle == True):
                        # print("Abbiamo un ciclo!")
                        self.stop = False
                        self.check_cycle = False
                    self.timer = 1000
                return None
            # se il drone non Ã¨ fermo, il timer viene impostato al massimo.
            else:
                self.timer = 1000
            # problematica col drone 4,cercare di far muovere il drone 4 (RISOLTA!)
            # if self.identifier == 4 :
            #     print("$$$$$$$")
            #     print("Metrica:",self.simulator.metrics.time_to_create_network_of_drones)
            #     print("Il drone:",self.identifier,"fermo:",self.stop, "coordinata:", self.coords, "Ã¨ connesso:",self.routing_algorithm.is_connected)
            #     print("Coordinata last mission coords", self.last_mission_coords)
            #     print("FLAG MOVE", self.flag_move)
            # if self.routing_algorithm.is_connected == False:
            #      print("SEI IL DRONE:", self.identifier)
            #      self.last_mission_coords = self.coords
            #      self.stop = False
            if self.flag_goes_out_network == True:
                self.flag_move = True

            if self.flag_move == False:
                self.move_routing = True
            else:
                self.move_routing = False

            if self.move_routing or self.come_back_to_mission:
                # metrics: number of time steps on active routing (movement) a counter that is incremented each time
                # drone is moving to the depot for active routing, i.e., move_routing = True
                # or the drone is coming back to its mission
                self.simulator.metrics.time_on_active_routing += 1

            if self.move_routing:
                # print("In move routing Drone:", self.identifier)
                # self.coords = self.depot.coords
                if not self.last_move_routing:  # this is the first time that we are doing move-routing
                    self.last_mission_coords = self.coords

                self.__move_to_depot(time)

                if (self.parentPath != None):
                    # print("Drone: " + str(self.identifier) + "  distanza dal parent: " + str(
                    #     utilities.euclidean_distance(self.coords, self.parentPath.coords))
                    #       + " communication range " + str(self.communication_range), "il parent Ã¨",
                    #       self.parentPath.identifier)
                    self.lazy_movement(time)
                    self.flag_move = True
                else:
                    self.stop = False

            else:
                if self.last_move_routing or self.flag_goes_out_network:  # I'm coming back to the mission
                    self.come_back_to_mission = True
                    # print("DIECI MOVE", self.last_mission_coords)

                self.__move_to_mission(time)

                # metrics: number of time steps on mission, incremented each time drone is doing sensing mission
                self.simulator.metrics.time_on_mission += 1

                if (self.parentPath != None):
                    # print("Drone: " + str(self.identifier) + "  distanza dal parent: " + str(
                    #     utilities.euclidean_distance(self.coords, self.parentPath.coords))
                    #       + " communication range " + str(self.communication_range), "il parent Ã¨",
                    #       self.parentPath.identifier)
                    self.lazy_movement(time)
                    # if self.parentPath != None and math.ceil(utilities.euclidean_distance(self.coords,
                    #                                            self.parentPath.coords)) < self.communication_range:
                    #    self.stop = False
                else:
                    self.flag_move = False

            # set the last move routing

            self.last_move_routing = self.move_routing

    def send_message_to_parent_path(self, cur_step):
        """Questo metodo Ã¨ responsabile di inviare un parentPath message ai droni
            Il parent path viene in seguito utilizzato per verificare se ci sono cicli o meno"""
        if cur_step % config.HELLO_DELAY == 0:
            # all_drones = self.simulator.drones
            # closest_drones = [drone for drone in all_drones
            #                   if utilities.euclidean_distance(self.coords, drone.coords)
            #                   < min(self.communication_range, drone.communication_range)]

            # opt_command = 0
            if (self.timer <= 0):
                drone_parent = self.parentPath
                parent_packet = ParentPacket(self, cur_step, self.simulator)
                self.simulator.network_dispatcher.send_packet_to_medium(parent_packet, self, drone_parent, cur_step)

    def is_full(self):
        return self.buffer_length() == self.buffer_max_size

    def is_known_packet(self, packet: DataPacket):
        """ Returns True if drone has already a similar packet (i.e., referred to the same event).  """
        for pk in self.__buffer:
            if pk.event_ref == packet.event_ref:
                return True
        return False

    def empty_buffer(self):
        self.__buffer = []

    def all_packets(self):
        return self.__buffer

    def buffer_length(self):
        return len(self.__buffer)

    def remove_packets(self, packets):
        """ Removes the packets from the buffer. """
        for packet in packets:
            if packet in self.__buffer:
                self.__buffer.remove(packet)
                if config.DEBUG:
                    print("ROUTING del: drone: " + str(self.identifier) + " - removed a packet id: " + str(
                        packet.identifier))

    def next_target(self):
        if self.move_routing:
            return self.depot.coords
        elif self.come_back_to_mission:
            return self.last_mission_coords
        else:
            if self.current_waypoint >= len(self.path) - 1:  # reched the end of the path, start back to 0
                return self.path[0]
            else:
                return self.path[self.current_waypoint + 1]

    def __move_to_mission(self, time):
        """ When invoked the drone moves on the map. TODO: Add comments and clean.
            time -> time_step_duration (how much time between two simulation frame)
        """
        if self.current_waypoint >= len(self.path) - 1:
            self.current_waypoint = -1

        p0 = self.coords
        if self.come_back_to_mission:  # after move
            p1 = self.last_mission_coords
        else:
            p1 = self.path[self.current_waypoint + 1]

        all_distance = utilities.euclidean_distance(p0, p1)
        distance = time * self.speed
        if all_distance == 0 or distance == 0:
            self.__update_position(p1)
            return

        t = distance / all_distance
        if t >= 1:
            self.__update_position(p1)
        elif t <= 0:
            print("Error move drone, ratio < 0")
            exit(1)
        else:
            self.coords = (((1 - t) * p0[0] + t * p1[0]), ((1 - t) * p0[1] + t * p1[1]))

    def __update_position(self, p1):
        if self.come_back_to_mission:
            self.come_back_to_mission = False
            self.coords = p1
        else:
            self.current_waypoint += 1
            self.coords = self.path[self.current_waypoint]

    def __move_to_depot(self, time):
        """ When invoked the drone moves to the depot. TODO: Add comments and clean.
            time -> time_step_duration (how much time between two simulation frame)
        """
        p0 = self.coords
        p1 = self.depot.coords

        all_distance = utilities.euclidean_distance(p0, p1)
        distance = time * self.speed
        if all_distance == 0:
            self.move_routing = False
            return

        t = distance / all_distance

        if t >= 1:
            self.coords = p1  # with the next step you would surpass the target
        elif t <= 0:
            print("Error routing move drone, ratio < 0")
            exit(1)
        else:
            self.coords = (((1 - t) * p0[0] + t * p1[0]), ((1 - t) * p0[1] + t * p1[1]))

    def __repr__(self):
        return "Drone " + str(self.identifier)

    def __hash__(self):
        return hash((self.identifier))


# ------------------ Environment ----------------------
class Environment(SimulatedEntity):
    """ The enviromnet is an entity that represents the area of interest on which events are generated.
     WARNING this corresponds to an old view we had, according to which the events are generated on the map at
     random and then maybe felt from the drones. Now events are generated on the drones that they feel with
     a certain probability."""

    def __init__(self, width, height, simulator):
        super().__init__(simulator)

        self.width = width
        self.height = height

        self.event_generator = EventGenerator(height, width, simulator)
        self.active_events = []

    def add_drones(self, drones: list):
        """ add a list of drones in the env """
        self.drones = drones

    def add_depot(self, depot: Depot):
        """ add depot in the env """
        self.depot = depot


class EventGenerator(SimulatedEntity):

    def __init__(self, height, width, simulator):
        """ uniform event generator """
        super().__init__(simulator)
        self.height = height
        self.width = width

    def uniform_event_generator(self):
        """ generates an event in the map """
        x = self.simulator.rnd_env.randint(0, self.height)
        y = self.simulator.rnd_env.randint(0, self.width)
        return x, y

    def poisson_event_generator(self):
        """ generates an event in the map """
        pass
